# VAKİT NAKİTTİR [CRYPTO]

Challenge
```
Bernard Fabrot ve Erdinç Öztürk çözdü sizde çözebilirsiniz ? (Bu kısmı tam net hatırlamıyorum ama önemli olan iki şey)

n = 3787102357961896108270209158853202347278150210262752942177381723026250766178612119181229766200100989211369981210023494731969982650714588114405341844658787058789210038199613031312686019587646183150904839969690612886764923017310337874381296204644079381140956781143210056977695807466072293573636629934936937455045231263629479472496948877657896300524131990131911838076221685514025660365638200632151914756536119364799242883802414278042025317223165706686607770309185391545280055403546447680794008704481100675891491152554904326646209472424033894564254643178232487269846921085128336785094054992906250585217050562008870522989

z = 3659982597507671757852505740511564652986538075963461358658203030328379454858149732481338066262523195379931218584914494473520607380393653288205434550106197950989131216875086208823381464365162131660646779020227116968184447042414751727584355277208003825294699318710098178022444431795555877125605225866912366451994229304468002205696594022570531851102303163195182588192939658463467757669426518952427721045332168705099622824915171006204105910892152720945419932215586265052283223187171936564058566245587768022661645295141962332739461231065653573880024373909128488280849005919458612521854039595048923627142080147145004960064
    
t = 79685186856218

w = 2^(2^t) (mod n)

w^z
```


Bu soruyu gördüğümde ilk yaptığım şey 'Bernard Fabrot', 'Erdinç Öztürk' ve sayıları googleda aratmak oldu

MIT sitesinde challenge'in orjinal isminin LCS35 olduğunu buldum  : https://people.csail.mit.edu/rivest/lcs35-puzzle-description.txt

Githubta bu soruyu çözen algoritmanın reposuna ulaştım: https://github.com/supranational/lcs35

LCS35 Hesaplayabilmek için Python kodu burada : https://github.com/supranational/lcs35/blob/master/scripts/decode_lcs35.py

Elimizde algoritma var fakat soruyu çözebilmek için n sayısını faktörize etmemiz gerekiyor.

Fermat Factorization Algoritmasını kullanınca p ve q birbirine çok yakın olduğu için rahatça kırılabiliyor. 

Fermat Kodu:

```python

def isqrt(n):
	x=n
	y=(x+n//x)//2
	while(y<x):
		x=y
		y=(x+n//x)//2
	return x
def fermat(n):
	t0=isqrt(n)+1
	counter=0
	t=t0+counter
	temp=isqrt((t*t)-n)
	while((temp*temp)!=((t*t)-n)):
		counter+=1
		t=t0+counter
		temp=isqrt((t*t)-n)
	s=temp
	p=t+s
	q=t-s
	return p,q

n=3787102357961896108270209158853202347278150210262752942177381723026250766178612119181229766200100989211369981210023494731969982650714588114405341844658787058789210038199613031312686019587646183150904839969690612886764923017310337874381296204644079381140956781143210056977695807466072293573636629934936937455045231263629479472496948877657896300524131990131911838076221685514025660365638200632151914756536119364799242883802414278042025317223165706686607770309185391545280055403546447680794008704481100675891491152554904326646209472424033894564254643178232487269846921085128336785094054992906250585217050562008870522989
p,q=fermat(n)
print("p  : ",int(p))
print("q  : ",int(q))
```

Fermat Sonunda P ve Q Sayısı:

```
('p  : ', 61539437419933374852991991488561356664191669860564674939284655403827781860390681007400068748726643618004305431049324461860860405630708355194944653765255437709033105172955177474145433544063401047926880449774867577418486584843004973966760226479078778265137637159085970212298479086752179589273700626665456557117)
('q  : ', 61539437419933374852991991488561356664191669860564674939284655403827781860390681007400068748726643618004305431049324461860860405630708355194944653765255437709033105172955177474145433544063401047926880449774867577418486584843004973966760226479078778265137637159085970212298479086752179589273700626665456556017)
```

İlk etapta bulduğumuz LCS35 Algoritmasından yararlanarak soruyu çözebiliriz.

```python

#!/usr/bin/python3

'''
Copyright 2019 Erdinc Ozturk, SABANCI UNIVERSITY
Copyright 2019 Supranational LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import math
import binascii
import textwrap

# Compute A^E mod n
def modexp(A,E,n):
    expolen = E.bit_length()
    C = 1
    for i in range (expolen):
        C = (C*C)%n
        current_e_bit = ((E>>(expolen-1-i))%2)
        if (current_e_bit==1):
            C = (C*A)%n
        
    return C

n = 3787102357961896108270209158853202347278150210262752942177381723026250766178612119181229766200100989211369981210023494731969982650714588114405341844658787058789210038199613031312686019587646183150904839969690612886764923017310337874381296204644079381140956781143210056977695807466072293573636629934936937455045231263629479472496948877657896300524131990131911838076221685514025660365638200632151914756536119364799242883802414278042025317223165706686607770309185391545280055403546447680794008704481100675891491152554904326646209472424033894564254643178232487269846921085128336785094054992906250585217050562008870522989

z = 3659982597507671757852505740511564652986538075963461358658203030328379454858149732481338066262523195379931218584914494473520607380393653288205434550106197950989131216875086208823381464365162131660646779020227116968184447042414751727584355277208003825294699318710098178022444431795555877125605225866912366451994229304468002205696594022570531851102303163195182588192939658463467757669426518952427721045332168705099622824915171006204105910892152720945419932215586265052283223187171936564058566245587768022661645295141962332739461231065653573880024373909128488280849005919458612521854039595048923627142080147145004960064
    
t = 79685186856218

p= 61539437419933374852991991488561356664191669860564674939284655403827781860390681007400068748726643618004305431049324461860860405630708355194944653765255437709033105172955177474145433544063401047926880449774867577418486584843004973966760226479078778265137637159085970212298479086752179589273700626665456557117
q = 61539437419933374852991991488561356664191669860564674939284655403827781860390681007400068748726643618004305431049324461860860405630708355194944653765255437709033105172955177474145433544063401047926880449774867577418486584843004973966760226479078778265137637159085970212298479086752179589273700626665456556017

phi_n = (p-1)*(q-1)
u = modexp(2,t,phi_n)
w = modexp(2,u,n)

Res = w^z

print(binascii.unhexlify(hex(Res)[2:-1]))

```

FLAG: `STMCTF{y1ll4r_g3csede_ustund3n}`

Üzücü olan şey şu ki Fermat koduna farklı bi n sayısı çalıştırdığımı fark ettiğimde yarışma çoktan bitmişti. 